name: "Issue Work Started"
description: "Update issue work started date when Status field changes to In Progress"

on:
  # Manual trigger for testing and specific issue updates
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to update'
        required: true
        type: string

  # Automatic trigger for issue changes
  issues:
    types: [edited]

  # Daily schedule to check all issues and update Work Started field
  schedule:
    # Run at 11 PM UTC daily (23:00)
    - cron: '0 23 * * *'

permissions:
  repository-projects: write
  issues: read
  contents: read

jobs:
  update_work_started:
    # Skip if the actor is a bot to avoid infinite loops
    if: github.actor != 'github-actions[bot]' && github.actor != 'dependabot[bot]'
    runs-on: ubuntu-latest
    steps:
      - name: Determine Issue Number
        id: get_issue_number
        run: |
          # Extract issue number based on trigger type
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual trigger
            issue_number="${{ github.event.inputs.issue_number }}"
            echo "Manual trigger for issue #$issue_number"
          elif [[ "${{ github.event_name }}" == "issues" ]]; then
            # Issue events
            issue_number="${{ github.event.issue.number }}"
            echo "Issue event triggered for issue #$issue_number"

          else
            echo "Unknown trigger type: ${{ github.event_name }}, skipping"
            exit 0
          fi

          if [[ -z "$issue_number" || "$issue_number" == "null" ]]; then
            echo "Could not determine issue number, skipping"
            exit 0
          fi

          echo "issue_number=$issue_number" >> $GITHUB_OUTPUT
          echo "Processing issue #$issue_number"

      - name: Set Environment Variables
        run: |
          echo "project_id=PVT_kwDOA9MHEM4AjeTl" >> $GITHUB_ENV
          echo "work_started_field_id=PVTF_lADOA9MHEM4AjeTlzgzZQtk" >> $GITHUB_ENV
          echo "status_field_id=PVTSSF_lADOA9MHEM4AjeTlzgb1Hjo" >> $GITHUB_ENV

      - name: Get Issue ID
        id: get_issue_id
        run: |
          issue_number="${{ steps.get_issue_number.outputs.issue_number }}"
          echo "Getting issue ID for issue #$issue_number"
          issue_details=$(curl -H "Authorization: Bearer ${{ secrets.TT_FORGE_PROJECT }}" -s "https://api.github.com/repos/${{ github.repository }}/issues/$issue_number")
          issue_id=$(echo "$issue_details" | jq -r '.node_id')
          echo "issue_id=$issue_id" >> $GITHUB_ENV

      - name: Get Project Item ID
        id: get_item_id
        run: |
          source $GITHUB_ENV

          found_item_id=""
          cursor=""
          page_count=0

          echo "Searching for issue ID: $issue_id in project: $project_id"

          # Search through all pages to find the issue
          while true; do
            page_count=$((page_count + 1))
            echo "Searching page $page_count..."

            # Build the query with or without cursor
            if [[ -z "$cursor" ]]; then
              QUERY='query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: 100) {
                      pageInfo {
                        hasNextPage
                        endCursor
                      }
                      nodes {
                        id
                        content {
                          ... on Issue {
                            id
                          }
                        }
                      }
                    }
                  }
                }
              }'
              JSON_PAYLOAD=$(jq -n \
                --arg query "$QUERY" \
                --arg projectId "$project_id" \
                '{ query: $query, variables: { projectId: $projectId }}')
            else
              QUERY='query($projectId: ID!, $cursor: String!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: 100, after: $cursor) {
                      pageInfo {
                        hasNextPage
                        endCursor
                      }
                      nodes {
                        id
                        content {
                          ... on Issue {
                            id
                          }
                        }
                      }
                    }
                  }
                }
              }'
              JSON_PAYLOAD=$(jq -n \
                --arg query "$QUERY" \
                --arg projectId "$project_id" \
                --arg cursor "$cursor" \
                '{ query: $query, variables: { projectId: $projectId, cursor: $cursor }}')
            fi

            # Make the GraphQL request
            RESPONSE=$(curl -s -X POST -H "Authorization: Bearer ${{ secrets.TT_FORGE_PROJECT }}" \
                                  -H "Content-Type: application/json" \
                                  -d "$JSON_PAYLOAD" \
                                  https://api.github.com/graphql)

            # Check for errors
            ERRORS=$(echo "$RESPONSE" | jq -r '.errors // empty')
            if [[ -n "$ERRORS" && "$ERRORS" != "null" ]]; then
              echo "GraphQL Error: $ERRORS"
              exit 0
            fi

            # Look for the issue in current batch
            ITEM_ID=$(echo "$RESPONSE" | jq -r --arg issue_id "$issue_id" \
                        '.data.node.items.nodes[]? | select(.content.id==$issue_id) | .id')

            if [[ -n "$ITEM_ID" && "$ITEM_ID" != "null" ]]; then
              found_item_id="$ITEM_ID"
              echo "Found issue in project"
              break
            fi

            # Check if there are more pages
            has_next_page=$(echo "$RESPONSE" | jq -r '.data.node.items.pageInfo.hasNextPage // false')
            if [[ "$has_next_page" != "true" ]]; then
              echo "Searched all $page_count pages. No more pages available."
              break
            fi

            # Get cursor for next page
            cursor=$(echo "$RESPONSE" | jq -r '.data.node.items.pageInfo.endCursor')

            if [[ $page_count -gt 100 ]]; then
              echo "Searched 100 pages (10,000+ items). Stopping to prevent infinite loop."
              break
            fi
          done

          # If issue not found in project, exit with error
          if [[ -z "$found_item_id" ]]; then
            echo "Issue not found in project after searching all pages."
            echo "The issue may not be added to this project yet."
            echo "Please manually add the issue to the project first."
            exit 0
          fi

          echo "item_id=$found_item_id" >> $GITHUB_OUTPUT

      - name: Check Status Field
        if: steps.get_item_id.outputs.item_id != ''
        id: check_status
        run: |
          source $GITHUB_ENV

          # Query to get the current Status field value
          QUERY='query($itemId: ID!) {
            node(id: $itemId) {
              ... on ProjectV2Item {
                fieldValues(first: 20) {
                  nodes {
                    ... on ProjectV2ItemFieldSingleSelectValue {
                      field {
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                        }
                      }
                      name
                      optionId
                    }
                  }
                }
              }
            }
          }'

          JSON_PAYLOAD=$(jq -n \
            --arg query "$QUERY" \
            --arg itemId "${{ steps.get_item_id.outputs.item_id }}" \
            '{ query: $query, variables: { itemId: $itemId }}')

          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.TT_FORGE_PROJECT }}" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD" \
            https://api.github.com/graphql)

          ERRORS=$(echo "$RESPONSE" | jq -r '.errors // empty')
          if [[ -n "$ERRORS" && "$ERRORS" != "null" ]]; then
            echo "GraphQL Error checking status: $ERRORS"
            exit 0
          fi

          # Extract Status field value using both field ID and name for accuracy
          STATUS_VALUE=$(echo "$RESPONSE" | jq -r --arg status_field_id "$status_field_id" \
                         '.data.node.fieldValues.nodes[] |
                          select(.field.id==$status_field_id or .field.name=="Status") | .name')

          # Extract Work Started field value to check if it's already set
          WORK_STARTED_VALUE=$(echo "$RESPONSE" | jq -r --arg work_started_field_id "$work_started_field_id" \
                              '.data.node.fieldValues.nodes[] |
                               select(.field.id==$work_started_field_id or .field.name=="Work Started") | .date')

          if [[ "$STATUS_VALUE" == "In Progress" ]]; then
            if [[ -z "$WORK_STARTED_VALUE" || "$WORK_STARTED_VALUE" == "null" ]]; then
              echo "Status is 'In Progress' and Work Started is empty - proceeding with update"
              echo "should_update=true" >> $GITHUB_OUTPUT
            else
              echo "Status is 'In Progress' but Work Started already set to '$WORK_STARTED_VALUE' - skipping to avoid overwriting"
              echo "should_update=false" >> $GITHUB_OUTPUT
            fi
          elif [[ -z "$STATUS_VALUE" || "$STATUS_VALUE" == "null" ]]; then
            echo "Status field not found or empty - skipping update"
            echo "should_update=false" >> $GITHUB_OUTPUT
          else
            echo "Status is '$STATUS_VALUE' - not 'In Progress', skipping update"
            echo "should_update=false" >> $GITHUB_OUTPUT
          fi

      - name: Update Work Started Field
        if: steps.check_status.outputs.should_update == 'true'
        run: |
          current_date=$(date +%Y-%m-%d)
          echo "Setting Work Started date to: $current_date"

          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.TT_FORGE_PROJECT }}" \
            -H "Content-Type: application/json" \
            -d "{ \"query\": \"mutation { updateProjectV2ItemFieldValue(input: { projectId: \\\"${{ env.project_id }}\\\", itemId: \\\"${{ steps.get_item_id.outputs.item_id }}\\\", fieldId: \\\"${{ env.work_started_field_id }}\\\", value: { date: \\\"$current_date\\\" } }) { clientMutationId } }\" }" \
            https://api.github.com/graphql)

          ERRORS=$(echo "$RESPONSE" | jq -r '.errors // empty')
          if [[ -n "$ERRORS" && "$ERRORS" != "null" ]]; then
            echo "GraphQL Error: $ERRORS"
            exit 0
          fi

      - name: Verify Work Started Field Update
        if: steps.check_status.outputs.should_update == 'true'
        run: |
          source $GITHUB_ENV

          echo "Verifying Work Started field was updated..."

          # Query to get the current Work Started field value
          VERIFY_QUERY='query($itemId: ID!) {
            node(id: $itemId) {
              ... on ProjectV2Item {
                fieldValues(first: 20) {
                  nodes {
                    ... on ProjectV2ItemFieldDateValue {
                      field {
                        ... on ProjectV2Field {
                          id
                          name
                        }
                      }
                      date
                    }
                  }
                }
              }
            }
          }'

          JSON_PAYLOAD=$(jq -n \
            --arg query "$VERIFY_QUERY" \
            --arg itemId "${{ steps.get_item_id.outputs.item_id }}" \
            '{ query: $query, variables: { itemId: $itemId }}')

          VERIFY_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.TT_FORGE_PROJECT }}" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD" \
            https://api.github.com/graphql)



          WORK_STARTED_VALUE=$(echo "$VERIFY_RESPONSE" | jq -r --arg work_started_field_id "$work_started_field_id" \
                              '.data.node.fieldValues.nodes[] |
                               select(.field.id==$work_started_field_id or .field.name=="Work Started") | .date')

          echo "Work Started field updated to: $WORK_STARTED_VALUE"

  # Bulk processing job for scheduled runs
  bulk_update_work_started:
    # Only run on scheduled triggers (cron)
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - name: Set Environment Variables
        run: |
          echo "project_id=PVT_kwDOA9MHEM4AjeTl" >> $GITHUB_ENV
          echo "status_field_id=PVTSSF_lADOA9MHEM4AjeTlzgb1Hjo" >> $GITHUB_ENV
          echo "work_started_field_id=PVTF_lADOA9MHEM4AjeTlzgzZQtk" >> $GITHUB_ENV

      - name: Get All Repository Issues
        id: get_all_issues
        run: |
          echo "Fetching all open issues from repository..."

          # Initialize variables for pagination
          page=1
          all_issue_numbers=""

          # Fetch all pages of issues
          while true; do
            echo "Fetching page $page of issues..."

            issues_response=$(curl -s -H "Authorization: Bearer ${{ secrets.TT_FORGE_PROJECT }}" \
              "https://api.github.com/repos/${{ github.repository }}/issues?state=open&per_page=100&page=$page")

            # Check if we got any issues
            page_issue_count=$(echo "$issues_response" | jq 'length')
            if [[ "$page_issue_count" == "0" ]]; then
              echo "No more issues found on page $page"
              break
            fi

            # Extract issue numbers from this page
            page_issue_numbers=$(echo "$issues_response" | jq -r '.[].number')
            all_issue_numbers="$all_issue_numbers"$'\n'"$page_issue_numbers"

            echo "Found $page_issue_count issues on page $page"

            # Check if we got less than 100 issues (last page)
            if [[ "$page_issue_count" -lt 100 ]]; then
              echo "Last page reached (less than 100 issues)"
              break
            fi

            page=$((page + 1))

            # Safety check to prevent infinite loops
            if [[ $page -gt 50 ]]; then
              echo "Reached maximum pages (50). Stopping to prevent infinite loop."
              break
            fi
          done

          # Clean up and save issue numbers
          echo "$all_issue_numbers" | grep -v '^$' > /tmp/issue_numbers.txt
          total_issues=$(cat /tmp/issue_numbers.txt | wc -l)
          echo "Total open issues found: $total_issues"

      - name: Process All Issues
        run: |
          echo "Processing all issues to check Status and update Work Started..."
          processed_count=0
          updated_count=0

          while read -r issue_number; do
            if [[ -z "$issue_number" ]]; then
              continue
            fi

            echo "Processing issue #$issue_number..."
            processed_count=$((processed_count + 1))

            # Get issue node ID
            issue_details=$(curl -s -H "Authorization: Bearer ${{ secrets.TT_FORGE_PROJECT }}" \
              "https://api.github.com/repos/${{ github.repository }}/issues/$issue_number")
            issue_id=$(echo "$issue_details" | jq -r '.node_id')

            if [[ -z "$issue_id" || "$issue_id" == "null" ]]; then
              echo "Could not get issue ID for #$issue_number, skipping..."
              continue
            fi

            # Find item ID in project (reuse existing pagination logic)
            found_item_id=""
            cursor=""
            page_count=0

            while true; do
              page_count=$((page_count + 1))

              if [[ -z "$cursor" ]]; then
                QUERY='query($projectId: ID!) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      items(first: 100) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          id
                          content { ... on Issue { id } }
                        }
                      }
                    }
                  }
                }'
                JSON_PAYLOAD=$(jq -n --arg query "$QUERY" --arg projectId "$project_id" \
                  '{ query: $query, variables: { projectId: $projectId }}')
              else
                QUERY='query($projectId: ID!, $cursor: String!) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      items(first: 100, after: $cursor) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          id
                          content { ... on Issue { id } }
                        }
                      }
                    }
                  }
                }'
                JSON_PAYLOAD=$(jq -n --arg query "$QUERY" --arg projectId "$project_id" --arg cursor "$cursor" \
                  '{ query: $query, variables: { projectId: $projectId, cursor: $cursor }}')
              fi

              RESPONSE=$(curl -s -X POST -H "Authorization: Bearer ${{ secrets.TT_FORGE_PROJECT }}" \
                -H "Content-Type: application/json" -d "$JSON_PAYLOAD" https://api.github.com/graphql)

              ERRORS=$(echo "$RESPONSE" | jq -r '.errors // empty')
              if [[ -n "$ERRORS" && "$ERRORS" != "null" ]]; then
                echo "GraphQL Error finding issue #$issue_number: $ERRORS"
                break
              fi

              ITEM_ID=$(echo "$RESPONSE" | jq -r --arg issue_id "$issue_id" \
                '.data.node.items.nodes[]? | select(.content.id==$issue_id) | .id')

              if [[ -n "$ITEM_ID" && "$ITEM_ID" != "null" ]]; then
                found_item_id="$ITEM_ID"
                break
              fi

              has_next_page=$(echo "$RESPONSE" | jq -r '.data.node.items.pageInfo.hasNextPage // false')
              if [[ "$has_next_page" != "true" ]]; then
                break
              fi

              cursor=$(echo "$RESPONSE" | jq -r '.data.node.items.pageInfo.endCursor')

              if [[ $page_count -gt 100 ]]; then
                echo "Searched 100 pages for issue #$issue_number. Stopping."
                break
              fi
            done

            if [[ -z "$found_item_id" ]]; then
              echo "Issue #$issue_number not found in project, skipping..."
              continue
            fi

            # Check Status and Work Started fields
            STATUS_QUERY='query($itemId: ID!) {
              node(id: $itemId) {
                ... on ProjectV2Item {
                  fieldValues(first: 20) {
                    nodes {
                      ... on ProjectV2ItemFieldSingleSelectValue {
                        field { id name }
                        name
                      }
                      ... on ProjectV2ItemFieldDateValue {
                        field { id name }
                        date
                      }
                    }
                  }
                }
              }
            }'

            STATUS_JSON_PAYLOAD=$(jq -n --arg query "$STATUS_QUERY" --arg itemId "$found_item_id" \
              '{ query: $query, variables: { itemId: $itemId }}')

            STATUS_RESPONSE=$(curl -s -X POST -H "Authorization: Bearer ${{ secrets.TT_FORGE_PROJECT }}" \
              -H "Content-Type: application/json" -d "$STATUS_JSON_PAYLOAD" https://api.github.com/graphql)

            STATUS_ERRORS=$(echo "$STATUS_RESPONSE" | jq -r '.errors // empty')
            if [[ -n "$STATUS_ERRORS" && "$STATUS_ERRORS" != "null" ]]; then
              echo "Error checking fields for issue #$issue_number: $STATUS_ERRORS"
              continue
            fi

            # Extract Status field value
            STATUS_VALUE=$(echo "$STATUS_RESPONSE" | jq -r --arg status_field_id "$status_field_id" \
              '.data.node.fieldValues.nodes[] |
               select(.field.id==$status_field_id or .field.name=="Status") | .name')

            # Extract Work Started field value
            WORK_STARTED_VALUE=$(echo "$STATUS_RESPONSE" | jq -r --arg work_started_field_id "$work_started_field_id" \
              '.data.node.fieldValues.nodes[] |
               select(.field.id==$work_started_field_id or .field.name=="Work Started") | .date')

            # Check if Status is "In Progress" and Work Started is empty
            if [[ "$STATUS_VALUE" == "In Progress" && (-z "$WORK_STARTED_VALUE" || "$WORK_STARTED_VALUE" == "null") ]]; then
              echo "Issue #$issue_number has Status='In Progress' but no Work Started date - updating..."

              current_date=$(date +%Y-%m-%d)

              MUTATION_RESPONSE=$(curl -s -X POST \
                -H "Authorization: Bearer ${{ secrets.TT_FORGE_PROJECT }}" \
                -H "Content-Type: application/json" \
                -d "{ \"query\": \"mutation { updateProjectV2ItemFieldValue(input: { projectId: \\\"$project_id\\\", itemId: \\\"$found_item_id\\\", fieldId: \\\"$work_started_field_id\\\", value: { date: \\\"$current_date\\\" } }) { clientMutationId } }\" }" \
                https://api.github.com/graphql)

              MUTATION_ERRORS=$(echo "$MUTATION_RESPONSE" | jq -r '.errors // empty')
              if [[ -n "$MUTATION_ERRORS" && "$MUTATION_ERRORS" != "null" ]]; then
                echo "Error updating Work Started for issue #$issue_number: $MUTATION_ERRORS"
              else
                echo "✅ Updated Work Started for issue #$issue_number to $current_date"
                updated_count=$((updated_count + 1))
              fi
            else
              echo "Issue #$issue_number: Status='$STATUS_VALUE', Work Started='$WORK_STARTED_VALUE' - no update needed"
            fi

            # Add small delay to avoid rate limiting
            sleep 1

          done < /tmp/issue_numbers.txt

          echo "Summary: Processed $processed_count issues, updated $updated_count Work Started fields"
