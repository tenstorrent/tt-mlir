name: Test

on:
  workflow_call:
    inputs:
      docker_image:
        description: 'Docker image for the build'
        required: true
        type: string
      test_matrix:
        description: 'Test matrix for run-tests job'
        required: true
        type: string
      timeout:
        description: 'Timeout in minutes for the test job'
        required: false
        type: number
        default: 60

permissions:
  checks: write
  packages: write

jobs:
  # Run tests on TT hardware

  run-tests:

    timeout-minutes: ${{ inputs.timeout }}
    strategy:
      fail-fast: false
      matrix:
        build: ${{ fromJson(inputs.test_matrix) }}
    name: "run-tests (${{ matrix.build.runs-on }},${{ matrix.build.image }},${{ strategy.job-index }})"

    runs-on: ${{ matrix.build.sh-run && format('tt-ubuntu-2204-{0}-stable', matrix.build.runs-on) || fromJson(format('["{0}", "in-service"]', matrix.build.runs-on)) }}

    container:
      image: ${{ matrix.build.sh-run && format('harbor.ci.tenstorrent.net/{0}', inputs.docker_image) || inputs.docker_image }}
      options: ${{ matrix.build.container-options || '--device /dev/tenstorrent' }}
      volumes:
        - /dev/hugepages:/dev/hugepages
        - /dev/hugepages-1G:/dev/hugepages-1G
        - /etc/udev/rules.d:/etc/udev/rules.d
        - /lib/modules:/lib/modules
        - /opt/tt_metal_infra/provisioning/provisioning_env:/opt/tt_metal_infra/provisioning/provisioning_env

    steps:
    - uses: actions/checkout@v4
      with:
          fetch-depth: 0

    - name: Fetch job id
      id: fetch-job-id
      uses: tenstorrent/tt-github-actions/.github/actions/job_id@main
      with:
        job_name: "run-tests (${{ matrix.build.runs-on }},${{ matrix.build.image }},${{ strategy.job-index }})"

    - name: Set reusable strings
      id: strings
      shell: bash
      env:
        JOB_ID: ${{ steps.fetch-job-id.outputs.job_id }}
      run: |
        echo "work-dir=$(pwd)" >> "$GITHUB_OUTPUT"
        echo "build-output-dir=$(pwd)/build" >> "$GITHUB_OUTPUT"
        echo "install-output-dir=$(pwd)/install" >> "$GITHUB_OUTPUT"

    - name: Git safe dir
      run: git config --global --add safe.directory ${{ steps.strings.outputs.work-dir }}

    - name: Use install artifacts
      uses: tenstorrent/tt-forge/.github/actions/download-artifact@main
      with:
        name: install-artifacts-${{ matrix.build.image }}
        path: install
        github_token: ${{ secrets.GITHUB_TOKEN }}

    - name: Remove existing whls files
      shell: bash
      run: |
        rm -f *.whl

    - name: Download ttrt run whls
      uses: actions/download-artifact@v4
      with:
        name: ttrt-whl-${{ matrix.build.image }}

    - name: Install ttrt run whls
      shell: bash
      run: |
        source env/activate
        pip show ttrt && pip uninstall -y ttrt
        pip install ttrt-${{ env.version }}*.whl --upgrade

    - name: Download Build Artifacts
      uses: tenstorrent/tt-forge/.github/actions/download-artifact@main
      with:
        name: build-artifacts-${{ matrix.build.image }}
        path: build
        github_token: ${{ secrets.GITHUB_TOKEN }}

    # TG galaxy doesn't have support for dispatch on eth cores - thus need to disable it
    - name: Generate system descriptor
      shell: bash
      run: |
        source env/activate
        if [ "${{ matrix.build.runs-on }}" == "tg" ] || [ "${{ matrix.build.runs-on }}" == "p150" ]; then
          ttrt query --save-artifacts --disable-eth-dispatch
        else
          ttrt query --save-artifacts
        fi

    - name: Run Tests
      shell: bash
      env:
        GH_TOKEN: ${{ secrets.GH_TOKEN || github.token}}
        TTRT_LOGGER_LEVEL: "WARNING"
        LOGURU_LEVEL: "ERROR"
        TT_METAL_LOGGER_LEVEL: "FATAL"
      run: |
        # Run Tests
        source env/activate
        
        # Append localhost AND machine IP to no_proxy for Tracy capture and explorer (CIv2 proxy bypass)
        # See: https://github.com/tenstorrent/github-ci-infra/issues/1187
        # Tracy binds to gethostbyname(gethostname()), not localhost, so we need the machine's IP too
        # Also adding 0.0.0.0 to test if it helps with Tracy communication
        MACHINE_IP=$(hostname -I | awk '{print $1}')
        export no_proxy="${no_proxy:+$no_proxy,}localhost,127.0.0.1,::1,0.0.0.0,${MACHINE_IP}"
        export NO_PROXY="${NO_PROXY:+$NO_PROXY,}localhost,127.0.0.1,::1,0.0.0.0,${MACHINE_IP}"
        echo "DEBUG: Added to no_proxy: localhost,127.0.0.1,::1,0.0.0.0,${MACHINE_IP}"
        
        export WORK_DIR="$(pwd)"
        export BUILD_DIR="${{ steps.strings.outputs.build-output-dir }}"
        export INSTALL_DIR="${{ steps.strings.outputs.install-output-dir }}"

        export LD_LIBRARY_PATH="${{ steps.strings.outputs.install-output-dir }}/lib:${TTMLIR_TOOLCHAIN_DIR}/lib:${LD_LIBRARY_PATH}"
        export SYSTEM_DESC_PATH="${GITHUB_WORKSPACE}/ttrt-artifacts/system_desc.ttsys"
        export TT_METAL_RUNTIME_ROOT="${{ steps.strings.outputs.install-output-dir }}/tt-metal"
        export RUNS_ON="${{ matrix.build.runs-on }}"
        export IMAGE_NAME="${{ matrix.build.image }}"
        export RUN_ID="${{ github.run_id }}"
        export PATH="$WORK_DIR/.github/test_scripts:$PATH"
        ln -sf ${{ steps.strings.outputs.install-output-dir }} ${{ steps.strings.outputs.build-output-dir }}
        rm -rf test_reports || true
        mkdir -p test_reports
        rm -rf ttrt_results || true
        mkdir -p ttrt_results

        echo "Running lit tests..."
        llvm-lit --filter-out="optimizer" --xunit-xml-output ${{ steps.strings.outputs.work-dir }}/test_reports/report_${{matrix.build.runs-on}}_${{ matrix.build.image }}_${{strategy.job-index}}_${{steps.fetch-job-id.outputs.job_id}}.xml \
          ${{ steps.strings.outputs.build-output-dir }}/test

        echo
        echo
        echo "Running tests on ${{ matrix.build.runs-on }} with image ${{ matrix.build.image }}"
        cat << 'EOF' > _test_to_run.json
          ${{ toJson(matrix.build.tests) }}
        EOF
        cat _test_to_run.json

        python .github/scripts/python/run_tests_from_json.py "${{ matrix.build.runs-on }}" "${{ matrix.build.image }}" "${{ steps.fetch-job-id.outputs.job_id }}"

    - name: Process Test Summary
      if: success() || failure()
      id: run-tests
      shell: bash
      run: |
        # Print load average (1min, 5min, 15min)
        python3 -c "import os; print(f'Load average: {os.getloadavg()}')" || true
        
        # Check system resources
        echo "System resources:"
        echo "  CPU cores: $(nproc 2>/dev/null || echo 'unknown')"
        echo "  Memory: $(free -h 2>/dev/null | grep Mem | awk '{print $2 " total, " $3 " used, " $7 " available"}' || echo 'unknown')"
        echo "  Load average: $(cat /proc/loadavg 2>/dev/null | awk '{print $1 " " $2 " " $3}' || echo 'unknown')"
        
        # Check clocksource and TSC for Tracy timestamp accuracy
        echo "Checking clocksource and TSC stability..."
        cat /sys/devices/system/clocksource/clocksource0/current_clocksource 2>/dev/null || echo "No clocksource info available"
        dmesg 2>/dev/null | grep -i tsc || echo "No TSC info in dmesg (may need root)"
        
        # Check Tracy library locations
        echo "Checking Tracy library locations..."
        tracy_paths=(
          "build/lib/libtracy.so"
          "third_party/tt-metal/src/tt-metal/build/lib/libtracy.so"
          "install/lib/libtracy.so"
          "$BUILD_DIR/lib/libtracy.so"
          "$INSTALL_DIR/lib/libtracy.so"
        )
        for path in "${tracy_paths[@]}"; do
          if [ -f "$path" ]; then
            echo "  ✓ Found: $path ($(ls -lh "$path" | awk '{print $5}'))"
          else
            echo "  ✗ Missing: $path"
          fi
        done
        
        # Global search for libtracy.so in common locations
        echo "  Searching for all libtracy.so files..."
        find . -name "libtracy.so*" -type f 2>/dev/null | while read found; do
          echo "    Found: $found ($(ls -lh "$found" | awk '{print $5}'))"
        done || echo "    (find command failed or no files found)"
        
        # Also check system library paths
        echo "  Checking system library paths..."
        for syspath in /usr/lib /usr/local/lib /lib /lib64 /usr/lib64; do
          if [ -f "$syspath/libtracy.so" ]; then
            echo "    ✓ Found in: $syspath"
          fi
        done
        
        # Check shared library dependencies for ttrt, tt-mlir, and tt-metal
        echo "Checking shared library dependencies..."
        
        # Check the ttrt Python package's runtime libraries
        echo "  Looking for ttrt runtime libraries..."
        find . -path "*/ttrt/runtime/*.so" -type f 2>/dev/null | head -3 | while read lib; do
          echo "    Found: $lib"
          ldd "$lib" 2>/dev/null | grep -i tracy && echo "      ^ Has tracy dependency" || true
        done
        
        # Check install directory libs
        echo "  Checking install/lib/*.so..."
        if [ -d "install/lib" ]; then
          for lib in install/lib/libTTRuntimeTTNN.so install/lib/libtt_metal.so install/lib/libtracy.so*; do
            if [ -f "$lib" ]; then
              echo "    $lib:"
              readelf -d "$lib" 2>/dev/null | grep -E 'NEEDED.*tracy|RPATH|RUNPATH' | head -3 || echo "      (no tracy references)"
            fi
          done
        else
          echo "    install/lib not found"
        fi
        
        # Check build directory libs
        echo "  Checking build/lib/*.so..."
        if [ -d "build/lib" ]; then
          for lib in build/lib/libTTRuntimeTTNN.so build/lib/libtt_metal.so build/lib/libtracy.so*; do
            if [ -f "$lib" ]; then
              echo "    $lib:"
              readelf -d "$lib" 2>/dev/null | grep -E 'NEEDED.*tracy|RPATH|RUNPATH' | head -3 || echo "      (no tracy references)"
            fi
          done
        else
          echo "    build/lib not found"
        fi
        
        # Check any .so files that link to tracy
        echo "  Searching for any .so files linking to libtracy..."
        tracy_linking_libs=()
        find . -name "*.so*" -type f 2>/dev/null | while read sofile; do
          if readelf -d "$sofile" 2>/dev/null | grep -q "libtracy"; then
            echo "    $sofile links to libtracy"
            tracy_linking_libs+=("$sofile")
          fi
        done | head -5 || echo "    (none found)"
        
        # For each library that links to tracy, show which tracy it resolves to
        echo "  Resolving libtracy.so for each linking library..."
        for lib in ./build/runtime/lib/libTTMLIRRuntime.so \
                   ./build/python_packages/ttrt/runtime/_ttnncpp.so \
                   ./build/python_packages/ttrt/runtime/libtt_metal.so \
                   ./install/lib/libtt_metal.so; do
          if [ -f "$lib" ]; then
            echo "    $lib:"
            echo "      RPATH/RUNPATH:"
            readelf -d "$lib" 2>/dev/null | grep -E 'RPATH|RUNPATH' || echo "        (none)"
            echo "      Resolves libtracy to:"
            ldd "$lib" 2>/dev/null | grep libtracy || echo "        (ldd failed or no tracy)"
          fi
        done
        
        # Check if all libtracy.so files are the same (by comparing inodes or hashes)
        echo "  Comparing libtracy.so files..."
        find . -name "libtracy.so*" -type f 2>/dev/null | while read tracy_file; do
          inode=$(ls -i "$tracy_file" 2>/dev/null | awk '{print $1}')
          size=$(ls -lh "$tracy_file" 2>/dev/null | awk '{print $5}')
          md5=$(md5sum "$tracy_file" 2>/dev/null | awk '{print $1}' || echo "N/A")
          echo "    $tracy_file: inode=$inode size=$size md5=$md5"
        done
        
        # Check tt-mlir libraries in Python packages
        echo "  Checking tt-mlir libraries in Python packages..."
        for pkg_dir in ./build/python_packages/ttmlir ./build/python_packages/ttrt; do
          if [ -d "$pkg_dir" ]; then
            echo "    In $pkg_dir:"
            find "$pkg_dir" -name "*TTMLIR*.so" -type f 2>/dev/null | while read mlir_lib; do
              echo "      Found: $mlir_lib"
              if readelf -d "$mlir_lib" 2>/dev/null | grep -q "libtracy"; then
                echo "        ✓ Links to tracy"
                echo "        RPATH/RUNPATH:"
                readelf -d "$mlir_lib" 2>/dev/null | grep -E 'RPATH|RUNPATH' | head -2
                echo "        Resolves to:"
                ldd "$mlir_lib" 2>/dev/null | grep libtracy | head -1
              else
                echo "        ✗ Does not link to tracy"
              fi
            done
          fi
        done
        
        # Check where ttrt wheel installs tt-mlir
        echo "  Checking ttrt wheel installation..."
        ttrt_location=$(python3 -c "import ttrt; print(ttrt.__file__)" 2>/dev/null || echo "")
        if [ -n "$ttrt_location" ]; then
          ttrt_dir=$(dirname "$ttrt_location")
          echo "    ttrt installed at: $ttrt_dir"
          echo "    Looking for tt-mlir libs in ttrt installation..."
          find "$ttrt_dir" -name "*TTMLIR*.so" -type f 2>/dev/null | head -3 | while read lib; do
            echo "      $lib"
            ldd "$lib" 2>/dev/null | grep libtracy || echo "        (no tracy)"
          done
        else
          echo "    ttrt not installed or not importable"
        fi
        
        # Verify all libraries in ttrt/runtime resolve to the same tracy
        echo "  Verifying all ttrt/runtime libraries use same tracy..."
        if [ -d "build/python_packages/ttrt/runtime" ]; then
          echo "    Checking build/python_packages/ttrt/runtime/*.so:"
          for lib in build/python_packages/ttrt/runtime/libTTMLIRRuntime.so \
                     build/python_packages/ttrt/runtime/libtt_metal.so \
                     build/python_packages/ttrt/runtime/_ttnncpp.so; do
            if [ -f "$lib" ]; then
              tracy_path=$(ldd "$lib" 2>/dev/null | grep libtracy | awk '{print $3}')
              echo "      $(basename $lib) -> $tracy_path"
            fi
          done
          
          echo "    All tracy files should point to the same location above."
          echo "    If they point to different paths, that's the problem!"
        fi
        
        # Check if tracy_ops_data.csv has interleaved or separated message ordering
        echo "Checking Tracy message ordering in ops data..."
        find ttrt-artifacts -name "tracy_ops_data.csv" -type f 2>/dev/null | while read csv; do
          echo "Analyzing: $csv"
          mlir_loc_lines=$(grep -n "MLIR_OP_LOCATION" "$csv" | head -5 | cut -d: -f1 | tr '\n' ' ')
          device_op_lines=$(grep -n "TT_DNN_DEVICE_OP" "$csv" | head -5 | cut -d: -f1 | tr '\n' ' ')
          echo "  First 5 MLIR_OP_LOCATION lines: $mlir_loc_lines"
          echo "  First 5 TT_DNN_DEVICE_OP lines: $device_op_lines"
          
          # Check if messages are interleaved (difference between consecutive line numbers < 50)
          first_mlir=$(echo $mlir_loc_lines | awk '{print $1}')
          first_device=$(echo $device_op_lines | awk '{print $1}')
          if [ -n "$first_mlir" ] && [ -n "$first_device" ]; then
            diff=$((first_device - first_mlir))
            if [ ${diff#-} -lt 50 ]; then
              echo "  ✓ Messages appear INTERLEAVED (diff: $diff lines)"
            else
              echo "  ✗ Messages appear SEPARATED (diff: $diff lines)"
            fi
          fi
        done || true
        
        # Copy perf artifacts for debugging (tracy_ops_data.csv, ops_perf_results.csv, etc.)
        # Do this before summary processing so we get artifacts even if tests fail
        echo "Copying perf artifacts to ttrt_results for upload..."
        if [ -d "ttrt-artifacts" ]; then
          find ttrt-artifacts -name "perf" -type d -exec cp -r {} ttrt_results/ \; 2>/dev/null || true
          find ttrt-artifacts -name "*.csv" -exec cp {} ttrt_results/ \; 2>/dev/null || true
          find ttrt-artifacts -name "*.tracy" -exec cp {} ttrt_results/ \; 2>/dev/null || true
          echo "Perf artifacts copied:"
          ls -la ttrt_results/ || true
        else
          echo "No ttrt-artifacts directory found"
        fi
        
        summary_content=$(cat _test_summary | tr '\n' '\r' | sed 's/\r/<br \/>/g')
        echo "summary=$summary_content" >> $GITHUB_OUTPUT
        mv _test_summary ${{ steps.strings.outputs.work-dir }}/test_reports/summary_${{ matrix.build.runs-on }}_${{ matrix.build.image }}_${{ strategy.job-index }}_${{ steps.fetch-job-id.outputs.job_id }}.md

    - name: Upload Test Durations
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: test-durations-${{ matrix.build.runs-on }}-${{ matrix.build.image }}-${{ steps.fetch-job-id.outputs.job_id }}
        path: _test_duration
        if-no-files-found: 'ignore'

    - name: Upload ttrt test report json
      if: (success() || failure())
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.build.runs-on }}_${{ matrix.build.image }}_${{ steps.fetch-job-id.outputs.job_id }}_results
        path: ttrt_results
        if-no-files-found: 'ignore'

    - name: Upload Test Report xml
      uses: actions/upload-artifact@v4
      if: success() || failure()
      with:
        name: test-reports-${{ matrix.build.runs-on }}-${{ matrix.build.image }}-${{ steps.fetch-job-id.outputs.job_id }}
        path: test_reports
        if-no-files-found: 'ignore'

    - name: Show Test Report
      continue-on-error: true
      uses: mikepenz/action-junit-report@v5
      if: success() || failure()
      with:
        report_paths: ${{ steps.strings.outputs.work-dir }}/test_reports/report_*.xml
        check_name: ${{ matrix.build.runs-on }}, ${{ matrix.build.image }}, ${{ strategy.job-index }} Tests
        summary: ${{ steps.run-tests.outputs.summary }}
        job_summary: false


  test-summary:
    runs-on: ubuntu-latest
    needs: run-tests
    if: success() || failure()
    steps:
      - uses: actions/checkout@v4
      - name: Process test summary
        continue-on-error: true
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          .github/scripts/bash/get_test_summary.sh ${{ github.run_id }} true
          cat _summary.md >> $GITHUB_STEP_SUMMARY
          find test_reports -name "report_*.xml" -type f -exec mv {} test_reports/ \;

      - name: Show consolidated test report
        continue-on-error: true
        uses: mikepenz/action-junit-report@v5
        if: success() || failure()
        with:
          report_paths: test_reports/report_*.xml
          check_name: All Tests
