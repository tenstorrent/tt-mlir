// SPDX-FileCopyrightText: (c) 2025 Tenstorrent AI ULC
//
// SPDX-License-Identifier: Apache-2.0

#ifndef TTMLIR_DIALECT_TTIR_ANALYSIS_ALLOCATIONDEFS_H
#define TTMLIR_DIALECT_TTIR_ANALYSIS_ALLOCATIONDEFS_H

// TODO(vroubtsov) temp workaround for #4304 not being available yet
#if defined(__has_include)
#if __has_include("ttmlir/Asserts.h")
#include "ttmlir/Asserts.h"
#endif
#endif

#include "ttmlir/Support/Logger.h"

#include "mlir/IR/AsmState.h"
#include "mlir/IR/Operation.h"
#include "mlir/IR/Value.h"
#include "llvm/ADT/STLForwardCompat.h"

#include <tuple>
#include <utility>

namespace mlir::tt::ttir {

// Define some convenience macros local to `Analysis`.

#define TT_ALLOC_DEBUG(/* fmt, args */...)                                     \
  TTMLIR_DEBUG(ttmlir::LogComponent::Allocator, __VA_ARGS__)

#define TT_ALLOC_TRACE(/* fmt, args */...)                                     \
  TTMLIR_TRACE(ttmlir::LogComponent::Allocator, __VA_ARGS__)

#define TT_ALLOC_ERROR(/* fmt, args */...)                                     \
  do {                                                                         \
    auto &OS = llvm::errs();                                                   \
    OS.enable_colors(true);                                                    \
    OS.changeColor(llvm::raw_ostream::RED, /*bold=*/true);                     \
    OS << llvm::formatv(__VA_ARGS__) << "\n";                                  \
    OS.resetColor();                                                           \
  } while (false)

// clang-format off
#ifndef TT_IMPL_ASSERT_LOC_INFO

# define TT_assert(condition)                            ((void)0)
# define TT_assertv(condition, /* message[, args] */...) ((void)0)

# define TT_assert_open_range(x, a, b)                   ((void)0)
# define TT_assert_limit(x, limit)                       ((void)0)
# define TT_assert_exclusive_range(x, a, b)              ((void)0)
# define TT_assert_inclusive_range(x, a, b)              ((void)0)

# define TT_debug(condition)                             ((void)0)
# define TT_debugv(condition, /* message[, args] */...)  ((void)0)

# define TT_debug_open_range(x, a, b)                    ((void)0)
# define TT_debug_limit(x, limit)                        ((void)0)
# define TT_debug_exclusive_range(x, a, b)               ((void)0)
# define TT_debug_inclusive_range(x, a, b)               ((void)0)

#endif
// clang-format on

template <typename Enum>
[[nodiscard]] constexpr std::underlying_type_t<Enum> ordinal(Enum e) {
  return llvm::to_underlying(e);
}

namespace detail {
template <typename Compare, typename... Fields>
class lexicographical_field_comparator : Compare {
public:
  lexicographical_field_comparator(std::tuple<Fields...> &&fields)
      : fields(std::move(fields)) {}

  template <typename T>
  constexpr bool operator()(const T &lhs, const T &rhs) const {
    using indexes = std::make_index_sequence<sizeof...(Fields)>;

    return compare(lhs, rhs, indexes{});
  }

private:
  template <typename T, std::size_t... I>
  bool compare(const T &lhs, const T &rhs, std::index_sequence<I...>) const {
    return (static_cast<const Compare &>(*this))(
        std::tie(lhs.*std::get<I>(fields)...),
        std::tie(rhs.*std::get<I>(fields)...));
  }

  std::tuple<Fields...> fields;
};
} // namespace detail

/// Helper function for creating a lexicographic comparator
/// from an ordered list of struct member pointers, e.g
///
///   struct Priority {
///    std::size_t size;
///    std::int32_t k;
///   };
///   auto compare = make_lexicographical_field_comparator<std::less<>>(
///     &Priority::k,
///     &Priority::size
///   );
///
template <typename Compare, typename... Fields>
auto make_lexicographical_field_comparator(Fields... fields) {
  return detail::lexicographical_field_comparator<Compare, Fields...>{
      std::make_tuple(fields...)};
}

/// Syntactic sugar helper for printing MLIR Value %-names with
/// the same IDs as generated by the stock IR tools.
///
/// Usage:
///   void foo(func::FuncOp funcOp) {
///     [[maybe_unused]] AsOperandPrinter asOperand{funcOp};
///     ...
///     llvm::dbgs() << asOperand(...) << ...
///
struct AsOperandPrinter {
  mlir::AsmState state;

  struct PrintAdator {
    AsOperandPrinter *parent;
    mlir::Operation *op = nullptr;
    mlir::Value *value = nullptr;

    friend llvm::raw_ostream &operator<<(llvm::raw_ostream &os,
                                         const PrintAdator &obj) {
      if (obj.op != nullptr) {
        if (obj.op->getNumResults() > 0) {
          obj.op->getResult(0).printAsOperand(os, obj.parent->state);
        } else {
          os << obj.op->getName();
        }
      } else {
        obj.value->printAsOperand(os, obj.parent->state);
      }
      return os;
    }
  };

  AsOperandPrinter(mlir::Operation *state) : state(state) {}

  PrintAdator operator()(mlir::Operation *op) { return {this, op, nullptr}; }
  PrintAdator operator()(mlir::Value *value) { return {this, nullptr, value}; }

  template <typename ConcreteOp>
  PrintAdator operator()(ConcreteOp op) {
    return this->operator()(op.getOperation());
  }
};

} // namespace mlir::tt::ttir

#endif // TTMLIR_DIALECT_TTIR_ANALYSIS_ALLOCATIONDEFS_H
